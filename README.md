# Demonstration-of-design-patterns-in-java
In developing!

Кратко по делу...

    Паттерн - это именнованное эфективное решение характерной задачи проектирования:
        * Именнованное - это значит что у каждого паттерна есть свое имя. По имени можно понять суть...
        * Характерной - часто повторяющейся.

    Паттерны (шаблоны проектирования) помогают:
         * не изобретать велосипед а использовать стандартное решение.
         * манипулирование на уровне абстракции, а не конкретных обьектов.
         * повторное использование, доработка
         * коммуникация между програмистами.

    Паттерны делятся на 3 группы:
    1) Порождающие - предостовляют механизмы инициализации, позволяя создавать обьекты удобным способом.
    2) Структурные - определяют отношения между классами и обьектами, позволяя им работать совместно.
    3) Поведенческие - используются для того чтобы упростить взаимодействия между сущностями.
    
    ПОРОЖДАЮЩИЕ:
        * Singleton (одиночка) - который гарантирует что у класса есть только один обьект (один экземпляр класса).
        И к этому обьекту предостовляется глобальная точка доступа.
        * Factory (фабрика) - используется когда у нас есть супер класс с несколькими подклассами и на основе
        ввода, нам нужно вернуть один из подклассов.
        * Abstract Factory (Абстрактная фабрика) - используем супер фабрики для создания фабрики, затем
        используем созданную фабрику для создания обьектов.
        * Builder (Строитель) - используется для создания сложного обьекта с использованием простых объектов,
        Постепенно он создает больший обьект от малого и простого обьекта.
        * Prototype (Прототип) - помогает создать дублированный объект с лучшей производительностью, вместо
        нового создается возвращаемый клон существующего обьекта.
     СТРУКТУРНЫЕ:
        * Decorator (Декоратор) или по другому Wrapper (Обертка) - добавляет новые функциональные возможности
        существующего объекта без привязки его структуры. (можно и чаще без наследования)
        * Adapter (Адаптер) - это конвертер между двумя несовместимыми объектами. Используя паттерн адаптера,
        мы можем объединить два несовместимых интерфейса. (есть 2 способа наследование и композиция)
        * Facade (Фасад) - обеспечивает простой интерфейс для клиента, и клиент использует интерфейс для
        взаимодействия с системой. А сложную внутреннюю систему скрывает.
        * Composite (Компоновщик) - использует один класс для представления древовидной структуры. Т.е. для
        группировки мелких компонентов в более крупные, которые после могут стать основой для еще более крупных.
        * Proxy (Заместитель) - представляет функциональность другого класса. Выступая его заместителем.
        * Flyweight (Легковес) - вместо создания большого количества похожих объектов, объекты используются
        повторно.
        * Bridge (Мост) - делает конкретные классы независимыми от классов реализации интерфейса.
     ПОВЕДЕНЧЕСКИЕ:
        * Observer (Наблюдатель) - позволяет одним обьектам следить и реагировать на события, происходящие
        в других объектах. Связь обьектов по принципу (издатель/подписчик) publish/subscriber.
        Наблюдатель ждет наступления определенных событий от издателя и с приходом событий оповещает
        всех подписчиков.
        * State (Состояние) - объект может изменять свое поведение в зависимости от его (внутреннего) состояния.
        Позволяет избегать многочисленных условий if.
